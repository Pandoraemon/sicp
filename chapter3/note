3.4 并发: 时间是个本质问题
3.4.1 并发系统中时间的性质

并发执行赋值操作的时候,可能会导致错误的结果,比如账户里有一百块钱,Paul 和 Peter 同时执行取钱的操作,
最后余额被最后执行完的人写入,而不是扣除两个人取掉的钱之和

解决这一错误的方式是对并发执行做限制,不允许2个写操作同时发生,即是加锁

3.4.2 控制并发的机制

串行化: 就是2个过程都要访问同一个共享变量的时候,不让这2个过程并行的发生,像书上的例子一样,把5种可能的结果降
为了2种,只与2个过程发生的先后有关.即将一开始举例的20种可能变成2种(a, b, c, x, y, z) 或 (x, y, z, a, b, c)

死锁: 进程 p1 访问共享资源 s1, 将 s1 锁住, 准备再去访问 s2, 但此时 p2 将 s2 锁住了,准备访问 s1, 此时将会无限等待
下去.避免死锁的一个方式是将进程标定优先级, 如果 p1 比 p2 优先级高,那么 p2 将 s2 先让出?

3.5 流

用赋值模拟对象随着时间的变化将模型变得复杂,我们可以用离散的序列去模拟时间函数.
将流模拟为表不能表示非常长的序列,所以这里引入了延时求值技术(我猜是类似 python 的生成器)

3.5.1

流计算和批量计算 代码见stream_and_batch.scm
迭代的方式只需要维持3个变量,而第二种方式需要先生成整个表,再进行 filter又生成一个表,最后再将表进行累加
如寻找100000到100000000之前第二个素数的例子,根本不需要把整个表先生成,找到第二个素数就可停止了.

流的实现

stream.scm
于之前有理数实现的后一个例子一样,steam-cdr 在构造的时候并不实现求值,而是在选取的时候再进行,这里基于 delay 实现.
delay 返回一个延时对象,force 求值延时对象

delay 和 force 的实现
(delay <exp>) 实际就是 (lambda () <exp>) 的一层语法糖. force 就是对这一过程的调用
(define (force delayed-object)
    (delayed-object))
实际使用中会遇到多次对用一个delay 对象求值的情况,可以在第一次求值后将结果保存起来
(define (memo-proc proc)
	(let ((already-run? false) (result false))
		(lambda ()
			(if (not already-run?)
				(begin (set! result (proc))
						(set! already-run? true)
						result)
				result))))

(delay <exp>) 等价于 (memo-proc (lambda () <exp>))


3.5.2 无穷流

厄拉多塞筛法
从2开始,将所有能被2整除的数筛掉,下一个是3,再将所有3的倍数筛掉,下一个是5....

隐式的定义流
与将 stream-cdr 的直接定义为生成过程不同, 流还可以通过类似于递归的方式来隐式的定义, 如 ones.scm

3.5.4 流计算模式的使用

序列加速器,能更快速的逼近收敛目标










